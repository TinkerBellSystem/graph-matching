### Proposal

We aim to design a graph matching algorithm (i.e., subgraph isomorphism) that matches every edge in the labeled provenance DAG to one (and only one) of a series of graph motifs. We assume for now that the query graph is static, although we may consider dynamic graphs in the future.

Provenance DAGs (i.e., query graphs) are labeled heterogeneous graphs with a finite set of vertex and edge labels. The structure of provenance DAGs follows a set of "rules" as they reflect principled activities that occurred in a system. We can graphically represent these rules by a series of graph motifs, which correspond to subgraphs within the DAG. When a certain action is taken by the system, its corresponding subgraphs will then appear in the DAG. However, unlike traditional graph motifs (e.g., a 4-node clique, a diamond) that consist of a fixed number of vertices and edges, graph motifs inferred from those rules are rather flexible. One way to imagine a graph motif is through regular language. Consider a set of edges, identified by letters A, B, C and D, that may appear in a motif. A graph motif of a provenance graph may be a structured version of A*(BC|D) or ABC?D. In the first case, we have an unknown number of nodes and edges because of the Kleene star operator while the latter case gives us two possibilities. Although we can always enumerate different cases for e.g., the "?", and "|"" operators and construct traditional graph motifs, we cannot do so for the * operator. 

Just like provenance DAGs themselves, provenance graph motifs are temporal, meaning that we know the order of the edges in a motif. Because of their regularity and temporality, we call provenance motifs "regular temporal motifs". Therefore, we are considering the problem of regular temporal subgraph isomorphism.

The nature of provenance graphs and that of provenance graph motifs gives us some additional properties we can work with. For example, as dicussed earlier, every edge in the query graph must be matched to one and only one motif. This is helpful because we can check the correctness of the matching once we have finished iterating the entire graph. Mismatch could happen since a provenance motif may itself be a subgraph of another motif, as motifs are constructed based on the semantics of system operations, not from a pure graph perspective.

Ideally, the algorithm results in linear (w.r.t the number of edges) time complexity and no worse than a polynomial one. Memory consumption is another concern since provenance graph can be large.